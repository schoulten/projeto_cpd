# -*- coding: utf-8 -*-
"""cpd_aula14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1umNcTWaEmFu6PTZw3ojYVDkfdIhZ7JQs

# **Projeto de Previsão de Demanda**
---

# Bibliotecas
"""

import pandas as pd
import numpy as np
import plotnine as p9
from statsmodels.tsa.seasonal import STL
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from statsmodels.tsa.holtwinters import ExponentialSmoothing

"""# Configurações de ambiente"""

pd.options.display.float_format = '{:.2f}'.format

"""# Coleta de Dados"""

# Fonte dos dados: https://www.kaggle.com/datasets/felixzhao/productdemandforecasting
df_bruto = pd.read_csv("https://aluno.analisemacro.com.br/download/69280/?tmstv=1768230842", compression = "zip")
df_bruto.head()

"""# Tramento de Dados"""

df_tratado = (
    df_bruto
    .copy()
    .assign(
        Date = lambda x: pd.to_datetime(x["Date"], format = "%Y/%m/%d"),
        Order_Demand = lambda x: x.Order_Demand.str.replace("\\(", "", regex = True).str.replace("\\)", "", regex = True).astype(int)
    )
)
df_tratado

"""# Análise Exploratória"""

# Quantos produtos tem?
df_tratado.Product_Code.nunique()

# Quantas categorias de produto tem?
df_tratado.Product_Category.nunique()

# Estatística descritiva
stat_desc = df_tratado.describe(include = "all")
stat_desc

# Qtd demandada de cada categoria de produto
df_tratado.groupby("Product_Category")["Order_Demand"].count().plot.bar();

# Análise temporal da categoria mais representativa
categoria_alvo = stat_desc.loc["top", "Product_Category"]
df_alvo = (
    df_tratado
    .query("Product_Category == @categoria_alvo")
    .groupby("Date")
    .Order_Demand
    .sum()
    .to_frame()
    .query("Date >= @pd.to_datetime('2012-01-01')")
    .Order_Demand
    .resample("W")
    .sum()
    .to_frame()
    .query("index <= @pd.to_datetime('2017-01-01')")
)
df_alvo

# Gráfico temporal
(
    p9.ggplot(df_alvo.reset_index()) +
    p9.aes(x = "Date", y = "Order_Demand") +
    p9.geom_line()
)

# Estatística descritiva
df_alvo.describe()

# Gráfico de histograma
(
    p9.ggplot(df_alvo.reset_index()) +
    p9.aes(x = "Order_Demand") +
    p9.geom_histogram()
)

# Análise de sazonalidade
stl = STL(df_alvo.Order_Demand, period = 52).fit()
stl.plot();

"""# Modelo Preditivo"""

# Criar regressores
month = df_alvo.index.month
df_regressao = (
    df_alvo
    .copy()
    .assign(
        tendencia = lambda x: ((df_alvo.reset_index().index + 1) + df_alvo.Order_Demand.mean()),
        sazonalidade = np.sin(2 * np.pi * month / 12)
        )
)
df_regressao

# Separa amostras treino/teste
df_treino = df_regressao.query("index <= @pd.to_datetime('2015-01-01')").copy()
df_teste = df_regressao.query("index > @pd.to_datetime('2015-01-01')").copy()
df_treino

# Regressão linear (fit)
modelo_rl = Pipeline(steps=[
    ("scaler", StandardScaler()),
    ("regressor", LinearRegression())
])
modelo_rl.fit(df_treino[["tendencia", "sazonalidade"]], df_treino["Order_Demand"])

# Regressão linear (forecast)
y_prev_rl = modelo_rl.predict(df_teste[["tendencia", "sazonalidade"]])
y_prev_rl

# Modelo ETS (fit)
modelo_ets = ExponentialSmoothing(
    df_treino.Order_Demand,
    trend = "add",
    seasonal = "add",
    seasonal_periods = 52
).fit(optimized = True)
modelo_ets

# Modelo ETS (forecast)
y_prev_ets = modelo_ets.forecast(len(df_teste))
y_prev_ets

"""# Avaliação e Diagnóstico"""

df_previsao = (
    pd.Series(y_prev_rl, index = df_teste.index)
    .rename("RL")
    .to_frame()
    .join(y_prev_ets.rename("ETS"))
    .join(df_teste["Order_Demand"])
)
df_previsao

df_previsao.plot();

# Cálculo de métricas de erro
y_true = df_previsao.Order_Demand
y_pred_rl = df_previsao.RL
y_pred_ets = df_previsao.ETS
print("Métricas RL")
print(f"Erro médio: {np.mean(y_true - y_pred_rl)}")
print(f"Erro médio absoluto: {np.mean(np.abs(y_true - y_pred_rl))}")
print(f"Raiz do erro médio quadrático: {np.sqrt(np.mean((y_true - y_pred_rl)**2))}\n\n")

print("Métricas ETS")
print(f"Erro médio: {np.mean(y_true - y_pred_ets)}")
print(f"Erro médio absoluto: {np.mean(np.abs(y_true - y_pred_ets))}")
print(f"Raiz do erro médio quadrático: {np.sqrt(np.mean((y_true - y_pred_ets)**2))}\n\n")

# Previsão fora da amostra
# Modelo ETS (fit)
modelo_ets_final = ExponentialSmoothing(
    df_alvo.Order_Demand,
    trend = "add",
    seasonal = "add",
    seasonal_periods = 52
).fit(optimized = True)

y_prev_ets = modelo_ets_final.forecast(52)
y_prev_ets

df_alvo.join(y_prev_ets.rename("ETS"), how = "outer")[["Order_Demand", "ETS"]].plot();

"""# Comunicação de Resultados"""



"""#"""